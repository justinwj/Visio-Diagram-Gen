
' Module: PingVisio
''''''''''''''''''''''''''''''''''''
Sub PingVisio()
    Dim visApp As Object
    Set visApp = CreateObject("Visio.Application")
    MsgBox "Visio version: " & visApp.Version          'should show 16.0.xxxx
    visApp.Quit
End Sub


''''''''''''''''''''''''''''''''''''
' Module: modDiagramCore
''''''''''''''''''''''''''''''''''''
' modDiagramCore
Option Explicit

' Ensure you have two class modules: clsMasterMeta and clsDiagramConfig
' clsMasterMeta with public properties: FileName, DisplayNameU, DisplayName, ID, Width, Height, Path, LangCode
' clsDiagramConfig with public properties: DiagramType, ModuleFilter, ProcFilter, ScaleMode, ExportFormat

' === Module-level declarations ===
Public gMasterDict As Object      ' Scripting.Dictionary of clsMasterMeta objects keyed by DisplayNameU
Private gConfig As clsDiagramConfig
' Module-level globals
Private gVisioApp As Visio.application
Private gWorkbook As Workbook
Private gShapeProvider As clsShapeProvider

' Initialize core services: Visio app, workbook, config, and shape providers
Public Sub Initialize(ByVal visApp As Visio.application, _
                      ByVal wb As Workbook, _
                      ByVal cfg As clsDiagramConfig)
    Set gVisioApp = visApp
    Set gWorkbook = wb
    Set gConfig = cfg

    ' Initialize the shape provider
    Set gShapeProvider = New clsShapeProvider
    gShapeProvider.Initialize gVisioApp

    ' Register map providers
    modDiagramMaps.ClearProviders
    Dim prov As Object
    Set prov = New clsCallSiteMapProvider
    modDiagramMaps.RegisterProvider prov
End Sub

' Accessor for Visio.Application
Public Property Get VisioApp() As Visio.application
    Set VisioApp = gVisioApp
End Property

' Accessor for Workbook context
Public Property Get Workbook() As Workbook
    Set Workbook = gWorkbook
End Property

' Accessor for DiagramConfig
Public Property Get Config() As clsDiagramConfig
    Set Config = gConfig
End Property

' Accessor for ShapeProvider
Public Property Get ShapeProvider() As clsShapeProvider
    Set ShapeProvider = gShapeProvider
End Property

Public Sub Generate()
    Dim shapes     As Collection
    Dim layoutAlg As clsLayoutAlgorithm
    Dim shapedDict As Scripting.Dictionary
    Dim connectors As Collection
    Dim drawingDoc As Visio.Document
    Dim pg         As Visio.page
    Dim builder    As clsDiagramBuilder

    ' 1) Gather shape items using gConfig
    Set shapes = modDiagramMaps.ExecuteProviders(gWorkbook, gConfig)
    '                                   ? gConfig, not cfg        :contentReference[oaicite:0]{index=0}

    ' 2) Layout them
    Set layoutAlg = New clsVerticalLayoutAlgorithm
    Set shapes = layoutAlg.Layout(shapes, gConfig) ' :contentReference[oaicite:1]{index=1}

    ' 3) New Visio page
    Set drawingDoc = gVisioApp.Documents.Add("")
    Set pg = drawingDoc.Pages(1)

    ' 4) Draw shapes
    Set builder = New clsDiagramBuilder
    builder.Initialize gVisioApp, pg
    Set shapedDict = builder.DrawItems(shapes, gShapeProvider)

    ' 5) (Stub) connectors
    Set connectors = New Collection
    If connectors.Count > 0 Then
        builder.DrawConnections connectors, shapedDict
    Else
        Debug.Print "No connectors to draw"
    End If

    Debug.Print "Generate: completed " & shapes.Count & " shapes and " & connectors.Count & " connectors."
End Sub

' === Master metadata infrastructure ===
'-------------------------------------------------------------------------------
' Load real metadata from the "StencilMasters" worksheet
' Builds gMasterDict of clsMasterMeta objects
'-------------------------------------------------------------------------------
' Version one: load metadata from the "StencilMasters" sheet
Public Sub LoadStencilMasterMetadataFromWorksheet()
    On Error Resume Next
    Call AddRequiredReferences
    On Error GoTo 0

    Dim dict As Object
    Set dict = CreateObject("Scripting.Dictionary")

    Dim ws As Worksheet
    Dim lastRow As Long, i As Long
    Dim key As String
    Dim meta As clsMasterMeta

    Set ws = ThisWorkbook.Worksheets("StencilMasters")
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row

    For i = 2 To lastRow
        key = Trim(CStr(ws.Cells(i, 2).Value))
        If Len(key) > 0 Then
            If Not dict.Exists(key) Then
                Set meta = New clsMasterMeta
                With meta
                    .FileName = CStr(ws.Cells(i, 1).Value)
                    .DisplayNameU = key
                    .DisplayName = CStr(ws.Cells(i, 3).Value)
                    .ID = CLng(ws.Cells(i, 4).Value)
                    .Width = CDbl(ws.Cells(i, 5).Value)
                    .Height = CDbl(ws.Cells(i, 6).Value)
                    .Path = CStr(ws.Cells(i, 7).Value)
                    .LangCode = CStr(ws.Cells(i, 8).Value)
                End With
                dict.Add key, meta
            Else
                Debug.Print "Skipping duplicate key: " & key
            End If
        End If
    Next i

    Set gMasterDict = dict
    Debug.Print "LoadStencilMasterMetadataFromWorksheet: Loaded " & dict.Count & " unique master(s)."
End Sub

Public Function GetMasterMetadata(ByVal masterNameU As String) As clsMasterMeta
    If gMasterDict Is Nothing Then LoadStencilMasterMetadataFromWorksheet
    If gMasterDict.Exists(masterNameU) Then
        Set GetMasterMetadata = gMasterDict(masterNameU)
    Else
        Err.Raise vbObjectError + 513, "GetMasterMetadata", _
            "Master '" & masterNameU & "' not found in metadata."
    End If
End Function

' === Configuration loader ===
' Reads values from the DiagramConfig table into the cfg object
Public Sub LoadDiagramConfig(ByVal cfg As clsDiagramConfig)
    Dim ws As Worksheet
    Dim tbl As ListObject
    Dim rw As ListRow
    Dim key As String, val As Variant
    Set ws = ThisWorkbook.Worksheets("DiagramConfig")
    On Error GoTo ErrHandler
    Set tbl = ws.ListObjects("DiagramConfig")
    For Each rw In tbl.ListRows
        key = UCase(Trim(rw.Range.Cells(1, 1).Value))
        val = rw.Range.Cells(1, 2).Value
        Select Case key
            Case "DIAGRAMTYPE":    cfg.DiagramType = val
            Case "MODULEFILTER":   If Len(val) > 0 Then cfg.moduleFilter = val
            Case "PROCFILTER":     If Len(val) > 0 Then cfg.procFilter = val
            Case "SCALEMODE":      cfg.ScaleMode = val
            Case "EXPORTFORMAT":   cfg.ExportFormat = val
        End Select
    Next rw
    Exit Sub
ErrHandler:
    Debug.Print "Error loading DiagramConfig: ", Err.Description
End Sub

' Factory function to create and return a populated configuration
Public Function GetConfig() As clsDiagramConfig
    Dim cfg As clsDiagramConfig
    Set cfg = New clsDiagramConfig   ' Sets defaults in Class_Initialize
    LoadDiagramConfig cfg            ' Overwrite with table values
    Set GetConfig = cfg              ' Return the instance
End Function

' === Visio environment setup ===
' Placeholder for Visio initialization; avoids compile errors if not yet implemented
Public Sub PrepareVisioEnvironment()
    ' TODO: implement Visio application and document setup
End Sub

' === Main orchestrator ===
' RunDiagramGeneration: full pipeline using config-driven parameters
Public Sub RunDiagramGeneration()
    Dim cfg As clsDiagramConfig
    Dim items As Collection
    Dim result As Variant

    ' 1) Load user-defined settings
    Set cfg = GetConfig()
    Debug.Print "[Diagram] Type=" & cfg.DiagramType & _
                "; ModuleFilter=" & cfg.moduleFilter & _
                "; ProcFilter=" & cfg.procFilter

    ' 2) Parse and map VBA code to Visio stencil directives
    On Error Resume Next
    result = application.Run("modDiagramMaps.ParseAndMap", _
                             ThisWorkbook, cfg.moduleFilter, cfg.procFilter)
    On Error GoTo 0
    If TypeName(result) = "Collection" Then
        Set items = result
    Else
        Set items = New Collection
        Debug.Print "[Diagram] Warning: no mapped items returned."
    End If

    ' 3) Prepare Visio environment and load stencil masters
    PrepareVisioEnvironment
    LoadStencilMasterMetadataFromWorksheet

    ' 4) Render mapped items onto the Visio page
    DrawMappedElements items, cfg.ScaleMode, cfg.ExportFormat

    ' 5) Post-render: apply additional layout (tiling, fitting, etc.)
    ApplyLayout cfg.ScaleMode

    ' 6) Export diagram using configured format
    modDiagramExport.SaveDiagram cfg.ExportFormat

    Debug.Print "[Diagram] Generation complete."
End Sub
' Note: Adjust DrawMappedElements signature to accept config args
' Public Sub DrawMappedElements(ByVal items As Collection, ByVal ScaleMode As String, ByVal ExportFormat As String)
'     '  render shapes, apply ScaleMode settings, ready for export 
' End Sub

'-------------------------------------------------------------------------------
' DrawMappedElements
' Iterates gMasterDict and drops each master on the active Visio page
'-------------------------------------------------------------------------------
' DrawMappedElements now drops shapes solely from the opened stencil doc
'   ensures visApp, visDoc, and visPage are set
'   opens stencil if not already loaded
'   handles missing master gracefully
Public Sub DrawMappedElements(ByVal items As Collection, ByVal ScaleMode As String, ByVal ExportFormat As String)
    Dim visApp As Object
    Dim visDoc As Object
    Dim visPage As Object
    Dim stencilDoc As Object
    Dim masterShape As Object
    Const stencilName As String = "Basic_U.vssx"
    Dim item As clsDiagramItem

    ' 1) Get or create Visio application
    On Error Resume Next
    Set visApp = GetObject(, "Visio.Application")
    If visApp Is Nothing Then Set visApp = CreateObject("Visio.Application")
    On Error GoTo 0

    ' 2) Ensure a document and page exist
    If visApp.Documents.Count = 0 Then visApp.Documents.Add ""
    Set visDoc = visApp.ActiveDocument
    If visDoc Is Nothing Then Exit Sub  ' safety check
    If visDoc.Pages.Count = 0 Then visDoc.Pages.Add
    Set visPage = visApp.ActivePage

    ' 3) Open stencil for masters if needed
    On Error Resume Next
    Set stencilDoc = visApp.Documents(stencilName)
    If stencilDoc Is Nothing Then
        Set stencilDoc = visApp.Documents.OpenEx(stencilName, 4)
    End If
    On Error GoTo 0

    ' 4) Drop each item
    For Each item In items
        Set masterShape = Nothing
        On Error Resume Next
        Set masterShape = stencilDoc.Masters(item.StencilNameU)
        On Error GoTo 0
        If masterShape Is Nothing Then
            Debug.Print "[Diagram] Warning: master '" & item.StencilNameU & "' not found in stencil."
        Else
            visPage.Drop masterShape, item.PosX, item.PosY
            visPage.shapes(visPage.shapes.Count).Text = item.LabelText
        End If
    Next item

    Debug.Print "[Diagram] Dropped " & items.Count & " shapes"
End Sub

' === Layout and scaling ===
Private Sub ApplyLayout(ByVal ScaleMode As String)
    Select Case LCase(ScaleMode)
        Case "fittopage"
            ActivePage.PageSheet.CellsU("Print.PageScale").FormulaU = "1"
            ActiveWindow.PageFit = 2  ' visFitPage
        Case "autotile"
            ' TODO: implement autotile layout
        Case Else
            ' No layout
    End Select
End Sub

'--- Stub for loading metadata in modDiagramCore ---
' Version two: stub for testing via clsShapeProvider, with guaranteed active document/page
Public Function LoadStencilMasterMetadata(ByVal provider As clsShapeProvider, _
                                         ByVal stencilPath As String, _
                                         ByVal masterNameU As String) As clsMasterMeta
    Dim meta As clsMasterMeta
    Dim m As Visio.master
    Dim app As Visio.application
    Dim visDoc As Visio.Document
    Dim pg As Visio.page
    Dim shp As Visio.Shape
    Set meta = New clsMasterMeta

    ' Retrieve Visio.Master and metadata
    Set m = provider.GetMaster(stencilPath, masterNameU)
    Set app = m.Document.application

    ' Ensure at least one document is open
    If app.Documents.Count = 0 Then
        Set visDoc = app.Documents.Add("")
    Else
        Set visDoc = app.ActiveDocument
    End If

    ' Ensure at least one page exists
    If visDoc.Pages.Count = 0 Then visDoc.Pages.Add
    Set pg = visDoc.Pages(1)   ' Use the first page explicitly

    ' Populate metadata properties
    meta.FileName = stencilPath
    meta.DisplayNameU = masterNameU
    meta.DisplayName = masterNameU
    meta.ID = m.ID

    ' Drop the shape and capture size
    On Error Resume Next
    Set shp = pg.Drop(m, 0, 0)
    If Not shp Is Nothing Then
        meta.Width = shp.CellsU("Width").ResultIU
        meta.Height = shp.CellsU("Height").ResultIU
        shp.Delete
    End If
    On Error GoTo 0

    meta.Path = stencilPath

    Set LoadStencilMasterMetadata = meta
End Function

'--- Test harness for full pipeline ---
Public Sub TestGenerate()
    Dim visApp As Visio.application
    On Error Resume Next
    Set visApp = GetObject(, "Visio.Application")
    If visApp Is Nothing Then Set visApp = New Visio.application
    On Error GoTo 0

    Dim cfg As clsDiagramConfig
    Set cfg = New clsDiagramConfig
    ' Optional: customize start point and spacing
    cfg.OriginX = 2
    cfg.OriginY = 8
    cfg.VerticalSpacing = 1.5

    ' Initialize and run
    Initialize visApp, ThisWorkbook, cfg
    Generate

    ' Report results
    Debug.Print "TestGenerate: Completed pipeline"
    Debug.Print "Shapes on page: " & visApp.ActivePage.shapes.Count
End Sub


''''''''''''''''''''''''''''''''''''
' Module: modDiagnose
''''''''''''''''''''''''''''''''''''
' modDiagnose -- tools for development
' Diagnostic routine to list all Masters in a Visio stencil and check for a specific master
Option Explicit

Sub Diag_ListStencilMasters(Optional ByVal masterToFind As String = "Container 1")
    Const visBuiltInStencilContainers As Long = 2
    Const visMSUS As Long = 0
    Const visOpenHidden As Long = 64

    Dim visApp As Object, stencilPath As String, stn As Object
    Dim m As Object, found As Boolean

    On Error GoTo ErrHandler

    Set visApp = CreateObject("Visio.Application")
    stencilPath = visApp.GetBuiltInStencilFile(visBuiltInStencilContainers, visMSUS)
    Set stn = visApp.Documents.OpenEx(stencilPath, visOpenHidden)

    Debug.Print "Masters in stencil (" & stencilPath & "):"
    found = False
    For Each m In stn.Masters
        Debug.Print "  - " & m.NameU
        If LCase$(m.NameU) = LCase$(masterToFind) Then found = True
    Next

    If found Then
        Debug.Print "Master '" & masterToFind & "' FOUND in stencil."
    Else
        Debug.Print "Master '" & masterToFind & "' NOT FOUND in stencil!"
        MsgBox "Master '" & masterToFind & "' not found in stencil: " & stencilPath, vbExclamation
    End If

    Exit Sub

ErrHandler:
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

'Call it once from Immediate to see every master in any stencil
' ListStencilMasters Application.GetBuiltInStencilFile(23, 0)   'Basic Flowchart
Sub ListStencilMasters(stencilPath As String)
    Dim stn As Object, m As Object
    Set stn = application.Documents.OpenEx(stencilPath, 64)   '64 = visOpenHidden
    Debug.Print "Masters in stencil (" & stencilPath & "):"
    For Each m In stn.Masters
        Debug.Print "  - "; m.NameU
    Next m
    stn.Close
End Sub

Sub Diag_ListBasicUMasters()
    Const stencilU$ = "BASIC_U.vssx"
    Const visOpenHidden As Long = 64
    Dim visApp As Object, stn As Object, m As Object

    Set visApp = CreateObject("Visio.Application")
    Set stn = visApp.Documents.OpenEx(stencilU, visOpenHidden)
    Debug.Print "Masters in stencil (" & stencilU & "):"
    For Each m In stn.Masters
        Debug.Print "  - " & m.NameU
    Next
    stn.Close
End Sub

' Diag_ListAllStencilMasters: Enumerates all Visio stencil masters in the Visio Content folder
' and extracts extended metadata to a worksheet for downstream use in modDiagramCore.
Public Sub Diag_ListAllStencilMasters()
    Const visOpenHidden As Long = 64
    Dim fso        As Object     ' Scripting.FileSystemObject
    Dim rootFolder As Object     ' Scripting.Folder
    Dim visApp     As Object     ' Visio.Application
    Dim basePath   As String
    Dim wb         As Workbook
    Dim ws         As Worksheet
    Dim rowIndex   As Long
    Dim calcMode   As XlCalculation
    Dim scUpdt     As Boolean

    ' Performance optimizations
    scUpdt = application.ScreenUpdating
    application.ScreenUpdating = False
    calcMode = application.Calculation
    application.Calculation = xlCalculationManual

    ' Prepare output worksheet
    Set wb = ThisWorkbook
    On Error Resume Next
    application.DisplayAlerts = False
    wb.Worksheets("StencilMasters").Delete
    application.DisplayAlerts = True
    On Error GoTo 0

    Set ws = wb.Worksheets.Add(After:=wb.Sheets(wb.Sheets.Count))
    ws.Name = "StencilMasters"

    ' Header row
    With ws
        .Cells(1, 1).Value = "Stencil File"
        .Cells(1, 2).Value = "Master NameU"
        .Cells(1, 3).Value = "Master Name"
        .Cells(1, 4).Value = "Master ID"
        .Cells(1, 5).Value = "Width"
        .Cells(1, 6).Value = "Height"
        .Cells(1, 7).Value = "Stencil Path"
        .Cells(1, 8).Value = "LanguageCode"
    End With
    rowIndex = 2

    ' Determine Visio Content folder (try common paths)
    basePath = Environ$("ProgramFiles") & "\Microsoft Office\root\Office16\Visio Content"
    If Dir(basePath, vbDirectory) = "" Then
        basePath = Environ$("ProgramFiles") & "\Microsoft Office\root\Visio\Visio Content"
    End If
    If Dir(basePath, vbDirectory) = "" Then
        MsgBox "Visio Content folder not found.", vbExclamation
        GoTo CleanUp
    End If

    ' Initialize FileSystemObject and Visio
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set rootFolder = fso.GetFolder(basePath)
    Set visApp = CreateObject("Visio.Application")
    visApp.Visible = False

    ' Extract masters recursively
    ExtractMastersToSheet rootFolder, visApp, visOpenHidden, ws, rowIndex

CleanUp:
    ' Cleanup Visio
    On Error Resume Next
    If Not visApp Is Nothing Then visApp.Quit
    Set visApp = Nothing
    Set rootFolder = Nothing
    Set fso = Nothing

    ' Restore Excel settings
    application.Calculation = calcMode
    application.ScreenUpdating = scUpdt

    MsgBox "Completed extracting stencil masters with metadata. See 'StencilMasters' sheet.", vbInformation
End Sub

' Recursive helper to open each stencil and write metadata
Private Sub ExtractMastersToSheet(folder As Object, visApp As Object, openFlags As Long, _
                                   ws As Worksheet, ByRef rowIndex As Long)
    Dim fileItem    As Object    ' Scripting.File
    Dim subFolder   As Object    ' Scripting.Folder
    Dim stencilDoc  As Object    ' Visio.Document
    Dim masterItem  As Object    ' Visio.Master
    Dim ext         As String
    Dim fPath       As String
    Dim fs          As Object
    Dim LangCode    As String
    Dim widthVal    As Double, heightVal As Double

    Set fs = CreateObject("Scripting.FileSystemObject")

    ' Determine language code from folder name
    LangCode = folder.Name

    For Each fileItem In folder.Files
        ext = LCase$(fs.GetExtensionName(fileItem.Name))
        If ext = "vss" Or ext = "vssx" Then
            fPath = fileItem.Path
            On Error Resume Next
            Set stencilDoc = visApp.Documents.OpenEx(fPath, openFlags)
            If Err.Number = 0 Then
                For Each masterItem In stencilDoc.Masters
                    ' Get default dimensions
                    On Error Resume Next
                    widthVal = masterItem.CellsU("Width").ResultIU
                    heightVal = masterItem.CellsU("Height").ResultIU
                    On Error GoTo 0

                    ws.Cells(rowIndex, 1).Value = fileItem.Name
                    ws.Cells(rowIndex, 2).Value = masterItem.NameU
                    ws.Cells(rowIndex, 3).Value = masterItem.Name
                    ws.Cells(rowIndex, 4).Value = masterItem.ID
                    ws.Cells(rowIndex, 5).Value = widthVal
                    ws.Cells(rowIndex, 6).Value = heightVal
                    ws.Cells(rowIndex, 7).Value = fPath
                    ws.Cells(rowIndex, 8).Value = LangCode
                    rowIndex = rowIndex + 1
                Next masterItem
                stencilDoc.Close
            Else
                Err.Clear
            End If
            On Error GoTo 0
        End If
    Next fileItem

    ' Recurse into subfolders
    For Each subFolder In folder.SubFolders
        ExtractMastersToSheet subFolder, visApp, openFlags, ws, rowIndex
    Next subFolder
End Sub


''''''''''''''''''''''''''''''''''''
' Module: modDiagramMaps
''''''''''''''''''''''''''''''''''''
' modDiagramMaps
Option Explicit

' Holds registered providers
Private providersCollection As Collection
' Module: modDiagramMaps
' Parses VBA modules and procedures into diagram items
' Applies moduleFilter and procFilter, instantiates clsDiagramItem objects,
' populates their properties, and returns a Collection of items.
' Parses VBA project, applies module and procedure filters,
' and returns a collection of clsDiagramItem for Visio rendering.

' Simplified ParseAndMap stub for testing without VBIDE ProcStartLine dependencies
Public Function ParseAndMap(wb As Workbook, moduleFilter As String, procFilter As String) As Collection
    Dim items As New Collection
    Dim vbComp As Object  ' Late-bound VBComponent
    Dim item As clsDiagramItem

    ' Loop through components matching moduleFilter
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Name Like moduleFilter Then
            ' Create a diagram item per module for stub
            Set item = New clsDiagramItem
            item.StencilNameU = "Rectangle"    ' default shape
            item.LabelText = vbComp.Name
            item.PosX = items.Count * 1#          ' simple horizontal layout
            item.PosY = 0#
            items.Add item
        End If
    Next vbComp

    ' Return collection of diagram items
    Set ParseAndMap = items
End Function

'===== Notes on update =====
'   Removed ProcStartLine/ProcCountLines usage to avoid VBIDE dependencies.
'   Now creates one item per VBComponent matching moduleFilter.
'   This stub ensures ParseAndMap compiles and runs regardless of VBIDE reference.
'   Replace with full implementation when ready to handle procedures and code scanning.

' Purpose: Registry for clsMapProvider implementations
' Register a map provider (accepts any object implementing GetItems)
Public Sub RegisterProvider(ByVal provider As Object)
    If providersCollection Is Nothing Then Set providersCollection = New Collection
    providersCollection.Add provider
End Sub

' Get the collection of registered providers
Public Function GetRegisteredProviders() As Collection
    If providersCollection Is Nothing Then Set providersCollection = New Collection
    Set GetRegisteredProviders = providersCollection
End Function

' Execute all providers against the workbook and config, aggregating items
Public Function ExecuteProviders(ByVal wb As Workbook, _
                                 ByVal cfg As clsDiagramConfig) As Collection
    Dim allItems As New Collection
    Dim prov As Object
    Dim items As Collection
    Dim itm As Variant

    For Each prov In GetRegisteredProviders()
        On Error Resume Next
        Set items = prov.GetItems(wb, cfg)
        On Error GoTo 0
        If Not items Is Nothing Then
            For Each itm In items
                allItems.Add itm
            Next itm
        End If
    Next prov

    Set ExecuteProviders = allItems
End Function

' Clear all registered providers (for re-initialization)
Public Sub ClearProviders()
    Set providersCollection = Nothing
End Sub


''''''''''''''''''''''''''''''''''''
' Module: modDiagramExport
''''''''''''''''''''''''''''''''''''
' Module: modDiagramExport
Option Explicit
' Stub for SaveDiagram to satisfy compile-time references from modDiagramCore

Public Sub SaveDiagram(ByVal ExportFormat As String)
        ' TODO: implement diagram export logic, e.g., ActiveDocument.SaveAs with ExportFormat
End Sub


''''''''''''''''''''''''''''''''''''
' Module: modDiagramAlgorithms
''''''''''''''''''''''''''''''''''''
' modDiagramAlgorithms
Option Explicit



''''''''''''''''''''''''''''''''''''
' Module: modTests
''''''''''''''''''''''''''''''''''''
' modTests
Option Explicit
' clsMasterMeta via shape provider
'--- Test harness for clsShapeProvider-based metadata loader ---
Public Sub TestMasterMeta()
    Dim visApp As Visio.application
    On Error Resume Next
    Set visApp = GetObject(, "Visio.Application")
    If visApp Is Nothing Then Set visApp = New Visio.application
    On Error GoTo 0

    Dim shpProv As clsShapeProvider
    Set shpProv = New clsShapeProvider
    shpProv.Initialize visApp

    Dim meta As clsMasterMeta
    Set meta = LoadStencilMasterMetadata(shpProv, "Basic_U.vssx", "Rectangle")

    Debug.Print "Loaded metadata for '" & meta.DisplayNameU & "': ID=" & meta.ID
    Debug.Print "  FileName: " & meta.FileName
    Debug.Print "  Path: " & meta.Path
    Debug.Print "  Width: " & meta.Width & ", Height: " & meta.Height
End Sub

' PASSED TEST clsShapeProvider
'--- Test harness for clsShapeProvider ---
Public Sub TestShapeProvider()
    Dim shpProv As clsShapeProvider
    Dim visApp As Visio.application
    Dim stencilPath As String
    Dim masterName As String
    Dim masterID As Long

    ' Acquire Visio instance (or start new)
    On Error Resume Next
    Set visApp = GetObject(, "Visio.Application")
    If visApp Is Nothing Then
        Set visApp = New Visio.application
    End If
    On Error GoTo 0

    ' Initialize provider
    Set shpProv = New clsShapeProvider
    shpProv.Initialize visApp

    ' Define test values (adjust path as needed)
    stencilPath = "Basic_U.vssx"
    masterName = "Rectangle"

    ' Fetch and print MasterID
    masterID = shpProv.GetMasterID(stencilPath, masterName)
    Debug.Print "Master ID for " & masterName & ": " & masterID
End Sub

' PASSED TEST clsCallSites, clsCallSiteMapProvider

' Test for clsDiagramBuilder.BuildConnections
Public Sub TestDiagramBuilder_BuildConnections()
    Dim builder      As clsDiagramBuilder
    Dim fakeApp      As Object
    Dim fakeDoc      As Object
    Dim fakePage     As Object
    Dim fakeShapes   As Object
    Dim connection   As Variant
    Dim connections  As Collection
    Dim connShapes   As Collection
    Dim connector    As Object

    ' Arrange fake Visio environment
    Set fakeApp = CreateObject("Scripting.Dictionary")
    Set fakeDoc = CreateObject("Scripting.Dictionary")
    Set fakePage = CreateObject("Scripting.Dictionary")
    Set fakeShapes = CreateObject("Scripting.Dictionary")

    ' Fake page.Shapes.ItemFromID returns a shape dict with ID key
    fakeShapes.Add 1001, CreateObject("Scripting.Dictionary"): fakeShapes(1001).Add "ID", 1001
    fakeShapes.Add 2002, CreateObject("Scripting.Dictionary"): fakeShapes(2002).Add "ID", 2002
    fakePage.Add "Shapes", fakeShapes
    fakeDoc.Add "Pages", CreateObject("Scripting.Dictionary"): fakeDoc("Pages").Add 1, fakePage

    ' Arrange connections
    Set connections = New Collection
    connections.Add Array(1001, 2002)

    ' Act
    ' Set builder = New clsDiagramBuilder
    ' Set builder.application = fakeApp
    ' Set builder.Document = fakeDoc
    ' Set connShapes = builder.BuildConnections(connections)

    ' Assert: one connector created
    If connShapes.Count <> 1 Then Err.Raise vbObjectError + 520, _
        "TestDiagramBuilder_BuildConnections", "Expected 1 connector, got " & connShapes.Count

    Debug.Print "TestDiagramBuilder_BuildConnections passed"
End Sub

' Test for scanning modules
Public Sub TestLoadAllCallSites()
    Dim calls As Collection
    Set calls = LoadAllCallSites()
    Debug.Print "Total call-sites found: " & calls.Count
    ' Optionally add assertions based on known codebase
End Sub

' Test for clsCallSite.GetID
Public Sub TestCallSite_GetID()
    Dim cs As clsCallSite
    Set cs = New clsCallSite
    cs.CallerModule = "ModuleA"
    cs.CallerProc = "Proc1"
    cs.CalleeModule = "ModuleB"
    cs.CalleeProc = "Proc2"

    If cs.GetID <> "ModuleA.Proc1->ModuleB.Proc2" Then
        Err.Raise vbObjectError + 513, "TestCallSite_GetID", _
            "Expected ID 'ModuleA.Proc1->ModuleB.Proc2', got '" & cs.GetID & "'"
    End If

    Debug.Print "TestCallSite_GetID passed"
End Sub

' Test for clsCallSiteMapProvider.MapCallSites
Public Sub TestCallSiteMapProvider()
    Dim sites As Collection
    Set sites = New Collection
    Dim cs As clsCallSite
    Dim fakeCaller As Object
    Dim fakeCallee As Object
    Dim shapesDict As Scripting.Dictionary
    Dim provider As clsCallSiteMapProvider
    Dim connections As Collection
    Dim conn As Variant

    ' Arrange: create a call-site
    Set cs = New clsCallSite
    cs.CallerModule = "ModuleA"
    cs.CallerProc = "Proc1"
    cs.CalleeModule = "ModuleB"
    cs.CalleeProc = "Proc2"
    sites.Add cs

    ' Arrange: fake shapes with IDs using dictionary
    Set fakeCaller = CreateObject("Scripting.Dictionary")
    fakeCaller.Add "ID", 1001
    Set fakeCallee = CreateObject("Scripting.Dictionary")
    fakeCallee.Add "ID", 2002

    Set shapesDict = New Scripting.Dictionary
    shapesDict.Add "ModuleA.Proc1", fakeCaller
    shapesDict.Add "ModuleB.Proc2", fakeCallee

    ' Act
    Set provider = New clsCallSiteMapProvider
    Set connections = provider.MapCallSites(sites, shapesDict)

    ' Assert: one connection returned
    If connections.Count <> 1 Then
        Err.Raise vbObjectError + 514, "TestCallSiteMapProvider", _
            "Expected 1 connection, got " & connections.Count
    End If

    ' Assert: correct IDs
    conn = connections(1)
    If conn(0) <> fakeCaller("ID") Or conn(1) <> fakeCallee("ID") Then
        Err.Raise vbObjectError + 515, "TestCallSiteMapProvider", _
            "Expected connection (" & fakeCaller("ID") & "," & fakeCallee("ID") & "), got (" & conn(0) & "," & conn(1) & ")"
    End If

    Debug.Print "TestCallSiteMapProvider passed"
End Sub

' PASSED TESTS clsDiagramConnection
Public Sub TestDrawConnections()
    Dim items As New Collection
    Dim conns As New Collection
    Dim it As clsDiagramItem
    Dim connObj As clsDiagramConnection
    Dim visApp As Object
    Dim visDoc As Object
    Dim visPage As Object
    Dim rectMaster As Object
    Dim stencil As Object
    Dim shp As Object

    ' Initialize Visio
    On Error Resume Next
    Set visApp = CreateObject("Visio.Application")
    On Error GoTo 0
    If visApp Is Nothing Then
        MsgBox "Visio not available.", vbCritical
        Exit Sub
    End If
    visApp.Visible = True

    ' Create a new Visio document
    Set visDoc = visApp.Documents.Add("")
    If visDoc Is Nothing Then
        MsgBox "Unable to create a Visio document.", vbCritical
        Exit Sub
    End If

    ' Ensure at least one page exists
    If visDoc.Pages.Count = 0 Then visDoc.Pages.Add
    Set visPage = visDoc.Pages(1)

    ' Open Basic Shapes stencil to get Rectangle master
    On Error Resume Next
    Set stencil = visApp.Documents.OpenEx("Basic Shapes.vssx", 64)
    If stencil Is Nothing Then Set stencil = visApp.Documents.OpenEx("Basic Shapes.vss", 64)
    On Error GoTo 0
    If stencil Is Nothing Then
        MsgBox "Unable to open Basic Shapes stencil.", vbCritical
        Exit Sub
    End If
    Set rectMaster = stencil.Masters("Rectangle")
    If rectMaster Is Nothing Then
        MsgBox "Master 'Rectangle' not found in stencil.", vbCritical
        Exit Sub
    End If

    ' Prepare test items
    Set it = New clsDiagramItem: it.LabelText = "A": it.PosX = 1: it.PosY = 5: items.Add it
    Set it = New clsDiagramItem: it.LabelText = "B": it.PosX = 3: it.PosY = 5: items.Add it

    ' Drop shapes on new drawing
    For Each it In items
        Set shp = visPage.Drop(rectMaster, it.PosX, it.PosY)
        shp.Text = it.LabelText
        shp.NameU = it.LabelText
    Next it

    ' Draw connection between shapes
    Set connObj = New clsDiagramConnection
    connObj.FromID = "A": connObj.ToID = "B": conns.Add connObj
   ' DrawConnections items, conns

    MsgBox "Diagram generated successfully.", vbInformation
End Sub

' PASSED TESTS clsDiagramItem
' Stub for testing mapping: returns a test collection of clsDiagramItem instances
Public Function TestParseAndMap(wb As Workbook, moduleFilter As String, procFilter As String) As Collection
    Dim items As New Collection
    Dim it As clsDiagramItem

    ' Example test nodes
    Set it = New clsDiagramItem
    it.StencilNameU = "Ellipse"
    it.LabelText = "Node A"
    it.PosX = 1#
    it.PosY = 1#
    items.Add it

    Set it = New clsDiagramItem
    it.StencilNameU = "Diamond"
    it.LabelText = "Node B"
    it.PosX = 4#
    it.PosY = 2#
    items.Add it

    Set TestParseAndMap = items
End Function

' Wrapper to test the TestParseAndMap stub in modDiagramMaps.bas
Public Sub TestRunParseAndMap()
    Dim items As Collection

    ' 1) Invoke real ParseAndMap implementation
    Set items = ParseAndMap(ThisWorkbook, "*", "*")
    Debug.Print "[Test] Parsed items count: " & items.Count

    ' 2) Prepare Visio and load stencil metadata
    PrepareVisioEnvironment
   '  LoadStencilMasterMetadata

    ' 3) Render parsed items using existing draw routine
    DrawMappedElements items, "FitToPage", "PNG"
    Debug.Print "[Test] Rendered parsed items"
End Sub

'===== Additional helper: list stencil master names =====
' Run this test to print the first 50 master names from the opened stencil
Public Sub TestListStencilMasters()
    Dim stencilDoc As Object
    Dim visApp As Object
    Dim m As Object
    Dim i As Long
    Const stencilName As String = "Basic_U.vssx"

    ' Attach to Visio and ensure stencil loaded
    On Error Resume Next
    Set visApp = GetObject(, "Visio.Application")
    If visApp Is Nothing Then Set visApp = CreateObject("Visio.Application")
    On Error GoTo 0
    Set stencilDoc = visApp.Documents(stencilName)
    If stencilDoc Is Nothing Then Set stencilDoc = visApp.Documents.OpenEx(stencilName, 4)

    ' List master names
    Debug.Print "Listing first 50 masters in " & stencilName
    i = 0
    For Each m In stencilDoc.Masters
        Debug.Print "  [" & m.Name & "]"
        i = i + 1
        If i >= 50 Then Exit For
    Next m
End Sub
' Stub to test rendering a single clsDiagramItem
Public Sub TestDrawSingleItem()
    Dim item As clsDiagramItem
    Dim items As Collection

    ' Prepare environment and stencils
    PrepareVisioEnvironment
    ' LoadStencilMasterMetadata

    ' Configure one diagram item (adjust name to match stencil master exactly)
    Set item = New clsDiagramItem
    item.StencilNameU = "Rectangle"   ' use a valid master name from the stencil   ' use exact master name from stencil (no extension)
    item.LabelText = "Test Node"
    item.PosX = 2#
    item.PosY = 3#

    ' Collect and render
    Set items = New Collection
    items.Add item
    DrawMappedElements items, "FitToPage", "PNG"

    Debug.Print "Rendered single test item: " & item.StencilNameU
End Sub

' PASSED TEST
' clsDiagramConfig
' Smoke test to verify config loading only
Public Sub TestLoadConfig()
    Dim ws As Worksheet
    Dim tbl As ListObject
    Dim rw As ListRow

    Set ws = ThisWorkbook.Worksheets("DiagramConfig")
    Set tbl = ws.ListObjects("DiagramConfig")
    
    Dim cfg As clsDiagramConfig
    Set cfg = GetConfig()
    Debug.Print "Type:    ", cfg.DiagramType
    Debug.Print "ModFil:  ", cfg.moduleFilter
    Debug.Print "PrFil:   ", cfg.procFilter
    Debug.Print "Scale:   ", cfg.ScaleMode
    Debug.Print "ExpFmt:  ", cfg.ExportFormat
    Debug.Print "Table found: " & tbl.Name
    For Each rw In tbl.ListRows
        Debug.Print "Row: " & rw.Range.Cells(1, 1).Value & " = " & rw.Range.Cells(1, 2).Value
    Next rw

End Sub

' PASSED TESTS clsMasterMeta
'-------------------------------------------------------------------------------
' Test routine for LoadStencilMasterMetadataStub
' Place this sub in a dedicated test module (e.g., modTest) to keep tests separate
'-------------------------------------------------------------------------------
Public Sub TestLoadStencilMasterMetadataStub()
    Dim dictMasters As Object
    Dim key As Variant
    Dim meta As clsMasterMeta
    
    ' Set dictMasters = LoadStencilMasterMetadataStub()
    If dictMasters Is Nothing Then
        MsgBox "LoadStencilMasterMetadataStub returned Nothing", vbCritical
        Exit Sub
    End If
    
    Debug.Print "--- Loaded Masters ---"
    For Each key In dictMasters.Keys
        Set meta = dictMasters(key)
        Debug.Print "Key=" & key & ", FileName=" & meta.FileName & _
                    ", DisplayName=" & meta.DisplayName & _
                    ", ID=" & meta.ID & _
                    ", Path=" & meta.Path
    Next key
    Debug.Print "Total masters: " & dictMasters.Count
    MsgBox "Test complete: " & dictMasters.Count & " master(s) loaded.", vbInformation
End Sub

'-------------------------------------------------------------------------------
' Test flow for master metadata + rendering stub
' Place this in modTests or modDiagramCore to verify end-to-end stub integration
'-------------------------------------------------------------------------------
Public Sub TestMasterFlow()
    ' Ensure the master dictionary is loaded
    ' LoadStencilMasterMetadata
    
    ' Quick check of contents
    If gMasterDict Is Nothing Or gMasterDict.Count = 0 Then
        MsgBox "No masters loaded!", vbCritical, "Master Flow Test"
        Exit Sub
    Else
        MsgBox "Loaded " & gMasterDict.Count & " master(s). Now testing DrawMappedElements.", vbInformation, "Master Flow Test"
    End If
    
    ' Call your existing draw routine (stub or real) to drop shapes
    ' Replace DrawMappedElements with your actual entry point
    Call DrawMappedElements_Sstub
End Sub

'-------------------------------------------------------------------------------
' Minimal stub for DrawMappedElements to confirm invocation
' Modify or replace with your real routine when ready
' Used by TestMasterFlow
'-------------------------------------------------------------------------------
Public Sub DrawMappedElements_Sstub()
    Dim key As Variant
    Dim meta As clsMasterMeta
    
    Debug.Print "--- Drawing Elements Stub ---"
    For Each key In gMasterDict.Keys
        Set meta = gMasterDict(key)
        ' In real code you'd call Visio.Drop meta.ID, meta.PosX, meta.PosY
        Debug.Print "Would drop shape '" & meta.DisplayNameU & "' from file '" & meta.FileName & "'."
    Next key
    MsgBox "DrawMappedElements stub executed for " & gMasterDict.Count & " shape(s).", vbInformation, "Draw Stub"
End Sub



''''''''''''''''''''''''''''''''''''
' Module: modImportExportAll
''''''''''''''''''''''''''''''''''''
'------------------------------------------------------------
' Module: modExportImportAll
' ----put these in the immediate window to run:----
' ExportAllCodeToSingleFiles
' ExportTablesHeadersAndControls
' SyncSheetsCodeBehind
' SyncFormsCodeBehind
' SyncClassModules
' SyncStandardModules

' ReplaceAllCodeFromFiles
' ExportAllModules

' ListSheetCodeNames
' ExportUserFormControls
' SyncSheetsCodeBehind_Diagnostics
'------------------------------------------------------------

Option Explicit
' Subroutine to export all modules, classes, forms, and Excel objects (sheets, workbook)
Sub ExportAllModules()
    Dim vbComp As VBIDE.VBComponent
    Dim exportPath As String
    Dim fso As Object
    Dim fileItem As Object

    ' Root folder path; ensure subfolders "Sheets", "Forms", "Modules", and "Class Modules" exist.
    exportPath = "D:\justinwj\Workbooks\0_PROJECT_invSys\Visio Diagram Gen"
    ' Ensure trailing backslash
    If Right(exportPath, 1) <> "\" Then exportPath = exportPath & "\"

    ' Make sure Excel is set to allow programmatic access to VBProject
    ' (Trust Center > Macro Settings > Trust access to the VBA project object model)

    For Each vbComp In ThisWorkbook.VBProject.VBComponents
        Select Case vbComp.Type
            Case vbext_ct_StdModule ' Standard Modules
                On Error Resume Next
                vbComp.Export exportPath & "Modules\" & vbComp.Name & ".bas"
                On Error GoTo 0

            Case vbext_ct_ClassModule ' Class Modules
                On Error Resume Next
                vbComp.Export exportPath & "Class Modules\" & vbComp.Name & ".cls"
                On Error GoTo 0

            Case vbext_ct_MSForm ' UserForms
                On Error Resume Next
                vbComp.Export exportPath & "Forms\" & vbComp.Name & ".frm"
                On Error GoTo 0

            Case vbext_ct_Document ' Sheets and ThisWorkbook
                On Error Resume Next
                vbComp.Export exportPath & "Sheets\" & vbComp.Name & ".cls"
                On Error GoTo 0
        End Select
    Next vbComp

    ' Remove FRX files from the Forms folder, if present
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FolderExists(exportPath & "Forms") Then
        For Each fileItem In fso.GetFolder(exportPath & "Forms").Files
            If LCase(fso.GetExtensionName(fileItem.Name)) = "frx" Then
                fileItem.Delete True
            End If
        Next fileItem
    End If

    MsgBox "Export complete!"
End Sub
' Updates Microsoft Visual Basic Editor with latest code from VSC or whatever IDE
Public Sub ReplaceAllCodeFromFiles()
    SyncStandardModules
    SyncClassModules
    SyncFormsCodeBehind
    SyncSheetsCodeBehind
    MsgBox "All VBA code synced!", vbInformation
End Sub
' Sync only .bas modules by removing and re-importing
Public Sub SyncStandardModules()
    Const ROOT_PATH As String = "D:\\justinwj\\Workbooks\\0_PROJECT_invSys\\Modules\\"
    Dim fso As Object
    Dim vbProj As VBIDE.VBProject
    Dim fileItem As Object
    Dim baseName As String
    Dim filePath As String

    Set fso = CreateObject("Scripting.FileSystemObject")
    Set vbProj = ThisWorkbook.VBProject

    If Not fso.FolderExists(ROOT_PATH) Then Exit Sub
    For Each fileItem In fso.GetFolder(ROOT_PATH).Files
        If LCase(fso.GetExtensionName(fileItem.Name)) = "bas" Then
            baseName = fso.GetBaseName(fileItem.Name)
            ' Skip the exporter module itself
            If LCase(baseName) = "modexportimportall" Then GoTo NextStandard
            filePath = fileItem.Path

            On Error Resume Next
            ' Remove existing module to avoid corruption
            vbProj.VBComponents.Remove vbProj.VBComponents(baseName)
            On Error GoTo 0
            ' Import fresh module
            vbProj.VBComponents.Import filePath
        End If
NextStandard:
    Next fileItem
    ' Notify user when standard modules are imported
    MsgBox "Standard modules imported successfully!", vbInformation
End Sub

' Sync only .cls class modules by removing and re-importing
Public Sub SyncClassModules()
    Const ROOT_PATH As String = "D:\\justinwj\\Workbooks\\0_PROJECT_invSys\\Class Modules\\"
    Dim fso As Object
    Dim vbProj As VBIDE.VBProject
    Dim fileItem As Object
    Dim baseName As String
    Dim filePath As String

    Set fso = CreateObject("Scripting.FileSystemObject")
    Set vbProj = ThisWorkbook.VBProject

    If Not fso.FolderExists(ROOT_PATH) Then Exit Sub
    For Each fileItem In fso.GetFolder(ROOT_PATH).Files
        If LCase(fso.GetExtensionName(fileItem.Name)) = "cls" Then
            baseName = fso.GetBaseName(fileItem.Name)
            filePath = fileItem.Path

            On Error Resume Next
            ' Remove existing class module to avoid corruption
            vbProj.VBComponents.Remove vbProj.VBComponents(baseName)
            On Error GoTo 0
            ' Import fresh class module
            vbProj.VBComponents.Import filePath
        End If
    Next fileItem
    ' Notify user when class modules are imported
    MsgBox "Class modules imported successfully!", vbInformation
End Sub
    
'updates FRM code to whatever is in ROOT_PATH & Forms
Public Sub SyncFormsCodeBehind()
    Const ROOT_PATH As String = "D:\justinwj\Workbooks\0_PROJECT_invSys\"
    Dim fso     As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    Dim vbProj  As VBIDE.VBProject: Set vbProj = ThisWorkbook.VBProject
    Dim folder  As Object, fileItem As Object
    Dim fileText As String, lines As Variant
    Dim i        As Long, startIdx As Long
    Dim codeBody As String
    Dim compName As String
    Dim vbComp   As VBIDE.VBComponent
    Dim lineText As String

    If Not fso.FolderExists(ROOT_PATH & "Forms\") Then Exit Sub
    Set folder = fso.GetFolder(ROOT_PATH & "Forms\")

    For Each fileItem In folder.Files
        If LCase(fso.GetExtensionName(fileItem.Name)) = "frm" Then
            compName = fso.GetBaseName(fileItem.Name)
            On Error Resume Next
            Set vbComp = vbProj.VBComponents(compName)
            On Error GoTo 0

            If vbComp Is Nothing Then
                Debug.Print "Form not in project: " & compName
            Else
                fileText = fso.OpenTextFile(fileItem.Path, 1).ReadAll
                lines = Split(fileText, vbCrLf)

                ' find first real code line
                startIdx = -1
                For i = LBound(lines) To UBound(lines)
                    lineText = Trim(lines(i))
                    If lineText = "Option Explicit" _
                       Or LCase(Left(lineText, 4)) = "sub " _
                       Or LCase(Left(lineText, 8)) = "function" _
                       Or LCase(Left(lineText, 7)) = "private" _
                       Or LCase(Left(lineText, 6)) = "public " Then
                        startIdx = i: Exit For
                    End If
                Next i

                If startIdx >= 0 Then
                    codeBody = ""
                    For i = startIdx To UBound(lines)
                        codeBody = codeBody & lines(i) & vbCrLf
                    Next i
                    With vbComp.CodeModule
                        .DeleteLines 1, .CountOfLines
                        .InsertLines 1, codeBody
                    End With
                Else
                    Debug.Print "  ? no code found in " & fileItem.Name
                End If
            End If
        End If
    Next fileItem

    MsgBox "Forms code-behind synced.", vbInformation
End Sub

' Updates Sheet (Microsoft Excel Objects) code to whatever is in ROOT_PATH
Public Sub SyncSheetsCodeBehind()
    Const ROOT_PATH As String = "D:\justinwj\Workbooks\0_PROJECT_invSys\Sheets\"
    Dim fso       As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    Dim vbProj    As VBIDE.VBProject: Set vbProj = ThisWorkbook.VBProject
    Dim folder    As Object, fileItem As Object
    Dim txt       As String, lines As Variant
    Dim codeBody  As String
    Dim i         As Long
    Dim trimmed   As String, lowerText As String
    Dim compName  As String
    Dim vbComp    As VBIDE.VBComponent

    If Not fso.FolderExists(ROOT_PATH) Then
        MsgBox "Sheets folder not found: " & ROOT_PATH, vbExclamation
        Exit Sub
    End If

    Set folder = fso.GetFolder(ROOT_PATH)
    For Each fileItem In folder.Files
        If LCase(fso.GetExtensionName(fileItem.Name)) = "cls" Then
            compName = fso.GetBaseName(fileItem.Name)

            On Error Resume Next
            Set vbComp = vbProj.VBComponents(compName)
            On Error GoTo 0
            If vbComp Is Nothing Then GoTo NextFile

            txt = fso.OpenTextFile(fileItem.Path, 1).ReadAll
            lines = Split(txt, vbCrLf)
            codeBody = ""

            For i = LBound(lines) To UBound(lines)
                trimmed = Trim(lines(i))
                lowerText = LCase(trimmed)

                If trimmed = "" Then
                    ' preserve blank lines
                    codeBody = codeBody & vbCrLf

                ElseIf Not ( _
                    lowerText Like "version *" Or _
                    lowerText Like "begin*" Or _
                    lowerText = "end" Or _
                    lowerText Like "attribute *" Or _
                    lowerText Like "mult?use *" _
                ) Then
                    codeBody = codeBody & lines(i) & vbCrLf
                End If
            Next i

            With vbComp.CodeModule
                .DeleteLines 1, .CountOfLines
                .InsertLines 1, codeBody
            End With

            Set vbComp = Nothing
        End If
NextFile:
    Next fileItem

    MsgBox "Sheets code-behind synced!", vbInformation
End Sub

Public Sub SyncSheetsCodeBehind_Diagnostics()
    Const ROOT_PATH As String = "D:\justinwj\Workbooks\0_PROJECT_invSys\Sheets\"
    Dim fso      As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    Dim vbProj   As VBIDE.VBProject: Set vbProj = ThisWorkbook.VBProject
    Dim folder   As Object, fileItem As Object
    Dim compName As String
    Dim vbComp   As VBIDE.VBComponent
    
    If Not fso.FolderExists(ROOT_PATH) Then
        MsgBox "Folder not found: " & ROOT_PATH, vbExclamation
        Exit Sub
    End If
    
    Set folder = fso.GetFolder(ROOT_PATH)
    Debug.Print "=== Files in Sheets\ ==="
    For Each fileItem In folder.Files
        If LCase(fso.GetExtensionName(fileItem.Name)) = "cls" Then
            compName = fso.GetBaseName(fileItem.Name)
            Debug.Print "File: "; fileItem.Name; " ? looking for component: "; compName
            
            On Error Resume Next
            Set vbComp = vbProj.VBComponents(compName)
            On Error GoTo 0
            
            If vbComp Is Nothing Then
                Debug.Print "   ? No matching VBComponent for "; compName
            Else
                Debug.Print "   ? Found VBComponent: "; vbComp.Name
                ' (Here you could inject your DeleteLines/InsertLines logic)
            End If
            Set vbComp = Nothing
        End If
    Next fileItem
    
    MsgBox "Diagnostics complete check the Immediate window (Ctrl+G).", vbInformation
End Sub

Sub ExportTablesHeadersAndControls()
    Dim ws As Worksheet
    Dim lo As ListObject
    Dim lc As ListColumn
    Dim ole As OLEObject
    Dim shp As Shape
    Dim folderPath As String, outputPath As String
    Dim Fnum As Long, hdrs As String
    Dim ctrlType As Long, ctrlTypeName As String
    ' 1) Set your folder (must already exist)
    folderPath = "D:\justinwj\Workbooks\0_PROJECT_invSys\"
    If Right(folderPath, 1) <> "\" Then folderPath = folderPath & "\"
    ' 2) Append filename
    outputPath = folderPath & "TablesHeadersAndControls.txt"
    Fnum = FreeFile
    Open outputPath For Output As #Fnum
    For Each ws In ThisWorkbook.Worksheets
        Print #Fnum, "Sheet (Tab):  " & ws.Name
        Print #Fnum, "Sheet (Code): " & ws.CodeName
        ' ? Tables & Headers ?
        For Each lo In ws.ListObjects
            Print #Fnum, "  Table: " & lo.Name
            hdrs = ""
            For Each lc In lo.ListColumns
                hdrs = hdrs & lc.Name & ", "
            Next lc
            If Len(hdrs) > 0 Then hdrs = Left(hdrs, Len(hdrs) - 2)
            Print #Fnum, "    Headers: " & hdrs
        Next lo
        ' ? ActiveX Controls ?
        For Each ole In ws.OLEObjects
            Print #Fnum, "  ActiveX Control: " & ole.Name & " (" & ole.progID & ")"
            On Error Resume Next
            Print #Fnum, "    LinkedCell: " & ole.LinkedCell
            Print #Fnum, "    TopLeft: " & ole.TopLeftCell.Address(False, False)
            Print #Fnum, "    Caption: " & ole.Object.Caption
            Print #Fnum, "    Value: " & ole.Object.Value
            On Error GoTo 0
        Next ole
        ' ? Forms Controls ?
        For Each shp In ws.shapes
            If shp.Type = msoFormControl Then
                ctrlType = shp.FormControlType
                Select Case ctrlType
                    Case 0: ctrlTypeName = "Button"
                    Case 1: ctrlTypeName = "Checkbox"
                    Case 2: ctrlTypeName = "DropDown"
                    Case 3: ctrlTypeName = "EditBox"
                    Case 4: ctrlTypeName = "ListBox"
                    Case 5: ctrlTypeName = "ScrollBar"
                    Case 6: ctrlTypeName = "Spinner"
                    Case Else: ctrlTypeName = "Unknown"
                End Select
                Print #Fnum, "  Form Control: " & shp.Name
                Print #Fnum, "    Type: " & ctrlTypeName & " (" & ctrlType & ")"
                On Error Resume Next
                Print #Fnum, "    LinkedCell: " & shp.ControlFormat.LinkedCell
                If shp.HasTextFrame Then
                    Print #Fnum, "    Text: " & Replace(shp.TextFrame.Characters.Text, vbCr, " ")
                End If
                On Error GoTo 0
            End If
        Next shp
        Print #Fnum, String(60, "-")
    Next ws
    Close #Fnum
    MsgBox "Export complete:" & vbCrLf & outputPath, vbInformation
End Sub
Sub ExportUserFormControls(frm As Object)
    Dim vbProj As VBIDE.VBProject
    Dim vbComp As VBIDE.VBComponent
    Dim ctrl As Object
    Dim outputPath As String, Fnum As Long
    '? adjust folder as needed (must exist) ?
    outputPath = "D:\justinwj\Workbooks\0_PROJECT_invSys\UserFormControls.txt"
    Fnum = FreeFile
    Open outputPath For Output As #Fnum
    Set vbProj = ThisWorkbook.VBProject
    For Each vbComp In vbProj.VBComponents
        ' only UserForm components
        If vbComp.Type = vbext_ct_MSForm Then
            Print #Fnum, "UserForm: " & vbComp.Name
            ' iterate its controls
            For Each ctrl In vbComp.Designer.Controls
                Print #Fnum, "  Control: " & ctrl.Name & " (" & TypeName(ctrl) & ")"
                On Error Resume Next
                ' many controls have a Caption
                Print #Fnum, "    Caption: " & ctrl.Caption
                ' and many have a Value
                Print #Fnum, "    Value: " & ctrl.Value
                On Error GoTo 0
            Next ctrl
            Print #Fnum, String(50, "-")
        End If
    Next vbComp
    Close #Fnum
    MsgBox "UserForm controls exported to:" & vbCrLf & outputPath, vbInformation
End Sub

' Requires reference to  Microsoft Visual Basic for Applications Extensibility 5.3 
' and Trust Center > Macro Settings >  Trust access to the VBA project object model  enabled.
' put all Sheets code into a single TXT file, all Forms code into a TXT file (except FRX files),
' all Class Modules code into a single TXT file and all Standard Modules code into a single TXT file
Public Sub ExportAllCodeToSingleFiles()
    Dim exportPath As String
    Dim wsFileNum   As Long, frmFileNum As Long
    Dim clsFileNum  As Long, modFileNum As Long
    Dim vbComp      As VBIDE.VBComponent
    Dim codeMod     As VBIDE.CodeModule
    
    ' ? Modify this to your desired folder (must already exist)
    exportPath = "D:\justinwj\Workbooks\0_PROJECT_invSys\Visio Diagram Gen"
    If Right(exportPath, 1) <> "\" Then exportPath = exportPath & "\"
    
    ' Open our four output files
    wsFileNum = FreeFile: Open exportPath & "SheetsCode.txt" For Output As #wsFileNum
    frmFileNum = FreeFile: Open exportPath & "FormsCode.txt" For Output As #frmFileNum
    clsFileNum = FreeFile: Open exportPath & "ClassModulesCode.txt" For Output As #clsFileNum
    modFileNum = FreeFile: Open exportPath & "StandardModulesCode.txt" For Output As #modFileNum
    
    ' Loop through every component in this workbook
    For Each vbComp In ThisWorkbook.VBProject.VBComponents
        Set codeMod = vbComp.CodeModule
        Select Case vbComp.Type
            Case vbext_ct_Document           ' Sheets & ThisWorkbook
                Print #wsFileNum, "''''''''''''''''''''''''''''''''''''"
                Print #wsFileNum, "' Component: " & vbComp.Name
                Print #wsFileNum, "''''''''''''''''''''''''''''''''''''"
                If codeMod.CountOfLines > 0 Then
                    Print #wsFileNum, codeMod.lines(1, codeMod.CountOfLines)
                End If
                Print #wsFileNum, vbCrLf
            
            Case vbext_ct_MSForm             ' UserForms
                Print #frmFileNum, "''''''''''''''''''''''''''''''''''''"
                Print #frmFileNum, "' UserForm: " & vbComp.Name
                Print #frmFileNum, "''''''''''''''''''''''''''''''''''''"
                If codeMod.CountOfLines > 0 Then
                    Print #frmFileNum, codeMod.lines(1, codeMod.CountOfLines)
                End If
                Print #frmFileNum, vbCrLf
            
            Case vbext_ct_ClassModule        ' Class modules
                Print #clsFileNum, "''''''''''''''''''''''''''''''''''''"
                Print #clsFileNum, "' Class Module: " & vbComp.Name
                Print #clsFileNum, "''''''''''''''''''''''''''''''''''''"
                If codeMod.CountOfLines > 0 Then
                    Print #clsFileNum, codeMod.lines(1, codeMod.CountOfLines)
                End If
                Print #clsFileNum, vbCrLf
            
            Case vbext_ct_StdModule          ' Standard (.bas) modules
                Print #modFileNum, "''''''''''''''''''''''''''''''''''''"
                Print #modFileNum, "' Module: " & vbComp.Name
                Print #modFileNum, "''''''''''''''''''''''''''''''''''''"
                If codeMod.CountOfLines > 0 Then
                    Print #modFileNum, codeMod.lines(1, codeMod.CountOfLines)
                End If
                Print #modFileNum, vbCrLf
        End Select
    Next vbComp
    
    ' Close all files
    Close #wsFileNum
    Close #frmFileNum
    Close #clsFileNum
    Close #modFileNum
    
    MsgBox "All code exported to:" & vbCrLf & _
           exportPath & vbCrLf & _
           "(SheetsCode.txt, FormsCode.txt, ClassModulesCode.txt, StandardModulesCode.txt)", _
           vbInformation
End Sub

Sub ListSheetCodeNames()
  Dim c As VBIDE.VBComponent
  For Each c In ThisWorkbook.VBProject.VBComponents
    If c.Type = vbext_ct_Document Then
      Debug.Print "Sheet CodeName: "; c.Name
    End If
  Next
End Sub





''''''''''''''''''''''''''''''''''''
' Module: modReferences
''''''''''''''''''''''''''''''''''''
Option Explicit

'-------------------------------------------------------------------------------
' Module: modReferences
' Purpose: Programmatically add the VBA project references needed by the diagram generator
' Requirements:
'  - "Trust access to the VBA project object model" must be enabled in Excel Trust Center
'  - Microsoft Visual Basic for Applications Extensibility 5.3 reference must be set (manually once)
'-------------------------------------------------------------------------------
Public Sub AddRequiredReferences()
    Dim vbProj As VBIDE.VBProject
    Set vbProj = ThisWorkbook.VBProject
    
    On Error Resume Next
    ' Microsoft Scripting Runtime
    vbProj.References.AddFromGuid _
        GUID:="{420B2830-E718-11CF-893D-00A0C9054228}", _
        Major:=1, Minor:=0
    ' Microsoft Forms 2.0 Object Library
    vbProj.References.AddFromGuid _
        GUID:="{0D452EE1-E08F-101A-852E-02608C4D0BB4}", _
        Major:=2, Minor:=0
    On Error GoTo 0

    ' You can add additional references here as needed
End Sub



''''''''''''''''''''''''''''''''''''
' Module: modCallSitesScanner
''''''''''''''''''''''''''''''''''''
' modCallSiteScanner.bas
Option Explicit

' Scans a VBComponent for call statements and returns CallSite objects
Public Function ScanModuleForCalls(component As VBIDE.VBComponent) As Collection
    Dim calls As New Collection
    Dim codeMod As VBIDE.CodeModule
    Dim totalLines As Long, lineNum As Long
    Dim regex As Object, matches As Object, m As Object
    Dim procName As String
    Dim cs As clsCallSite

    Set codeMod = component.CodeModule
    totalLines = codeMod.CountOfLines

    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "\b(\w+)\s*\.\s*(\w+)\s*\("  ' matches Module.Proc(
    regex.Global = True

    For lineNum = 1 To totalLines
        Dim lineText As String
        lineText = codeMod.lines(lineNum, 1)
        If regex.Test(lineText) Then
            Set matches = regex.Execute(lineText)
            procName = codeMod.ProcOfLine(lineNum, vbext_pk_Proc)
            For Each m In matches
                Set cs = New clsCallSite
                cs.CallerModule = component.Name
                cs.CallerProc = procName
                cs.CalleeModule = m.SubMatches(0)
                cs.CalleeProc = m.SubMatches(1)
                calls.Add cs
            Next m
        End If
    Next lineNum

    Set ScanModuleForCalls = calls
End Function

' Aggregates call-sites from all modules in the project
Public Function LoadAllCallSites() As Collection
    Dim allCalls As New Collection
    Dim proj As VBIDE.VBProject
    Dim comp As VBIDE.VBComponent
    Dim compCalls As Collection
    Dim cs As clsCallSite

    Set proj = ThisWorkbook.VBProject
    For Each comp In proj.VBComponents
        If comp.Type = vbext_ct_StdModule Or comp.Type = vbext_ct_ClassModule Then
            Set compCalls = ScanModuleForCalls(comp)
            For Each cs In compCalls
                allCalls.Add cs
            Next cs
        End If
    Next comp

    Set LoadAllCallSites = allCalls
End Function


''''''''''''''''''''''''''''''''''''
' Module: modDiagramUI
''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''
' Module: modDiagramConfig
''''''''''''''''''''''''''''''''''''


